# 💬 목차

[추상클래스와 인터페이스의 차이점에 대해 설명해주세요.](#추상클래스와 인터페이스의 차이점에 대해 설명해주세요.)  
[Garbage Collector란 무엇인가요?](#garbage-collector란-무엇인가요)  
[디스페처 서블릿은 어떤 역할을 하는지 설명해주세요](#디스페처-서블릿은-어떤-역할을-하는지-설명해주세요)  
[POJO(Plain-Old-Java-Object)란 무엇인가?](#POJO(Plain-Old-Java-Object)란-무엇인가)

# 추상클래스와 인터페이스의 차이점에 대해 설명해주세요.

## 추상 클래스 VS 인터페이스

### 공통점 ?

먼저 추상 클래스와 인터페이스의 공통점을 찾아보자.추상 클래스와 인터페이스 둘 다 **가지고 있는 추상 메서드를 구현하도록 강제한다.**또 **인스턴스화가 불가능**하다.

그렇다면 추상 클래스 안에 원하는 것만 추상 메서드를 여러개 두거나,전부 추상 메서드로 만들면 되어 추상 클래스가 인터페이스 역할을 할 수 있다.만약 모든 클래스가 인터페이스만 사용해서 구현한다면,모든 클래스에서 공통으로 필요한 기능들은 각각 오버라이딩 하게 되니 코드의 중복이 발생한다.때문에 이 공통으로 필요한 기능들을 부모 클래스에서 일반 메서드로 구현한추상클래스를 상속 받아 자식 클래스에서 사용할 수 있도록 하면 될거같은데...**왜 인터페이스는 왜 필요한걸까? 🤔**

### 접근자

**인터페이스**에서 모든 변수는 `public static final`,모든 메소드는 `public abstract`이다.하지만 **추상 클래스**에서는 `static`이나 `final`이 아닌 필드를 가질 수 있고,`public, protected, private` 모두 가질 수 있다.

개인적인 생각으로는 인터페이스만을 구현하면 `public static final`만을 사용해구현 객체의 같은 상태를 공유할수 밖에 없는데,추상 클래스는 `static`이나 `final`이 아닌 필드또한 가질 수 있기 때문에추상 클래스를 상속 받은 객체들이 같은 상태를 가지고 있을 수 있다.

### 다중 상속 여부

**인터페이스**를 구현하는 클래스는 다른 여러개 인터페이스를 함께 구현할 수 있다.하지만 자바에서는 다중 상속을 지원하지 않기 때문에 여러 추상 클래스를 상속할 수 없다.

### 사용 의도

물론 다중 상속 여부의 차이는 있지만 이것이 포인트가 아니라,이에 따른 사용 목적이 다르다는 것에 포인트를 맞춰보자.위에서 말한 다중 상속 여부에 따라 추상 클래스와 인터페이스의 사용 의도 또한 다르다.

**추상 클래스**는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로,상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며부모 클래스가 가진 기능들을 구현해야할 경우 사용한다.

**인터페이스**는 상속 관계를 타고 올라갔을 때다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다.클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용한다.

### Exmaple

아래와 같은 관계를 갖는 예제를 살펴본다.

![img.png](img.png)

### 각각의 적절한 사용 케이스 정리

### 추상 클래스

- 관련성이 높은 클래스 간에 코드를 공유하고 싶은 경우
- 추상 클래스를 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많거나,public이외의 접근자(protected, private) 선언이 필요한 경우
- non-static, non-final 필드 선언이 필요한 경우 (각 인스턴스에서 상태 변경을 위한 메소드가 필요한 경우)

### 인터페이스

- 서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는 경우.ex) Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데, 구현클래스들 간에 관련성이 없다.
- 특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우.
- 다중상속을 허용하고 싶은 경우


[추상클래스와 인터페이스](https://tranquil-queen-c5a.notion.site/73ecd4919d4f4a5ebf3a1a9a8dbcd217)

# Garbage Collector란 무엇인가요?

Java 이전의 C나 C++ 같은 언어에서는 개발자가 직접 메모리 할당과 해제를 컨트롤 해야했습니다.
때문에 개발자는 잦은 메모리 이슈로부터 자유로울수 없었는데, 이를 어느정도 해소하기 위해 가비지 컬렉터가 등장하였습니다.

### Garbage Collection(GC)
가비지 컬렉션이란, 메모리 관리 방법 중 하나로, 시스템에서 더이상 사용하지 않는
동적 할당된 메모리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것입니다.  
시스템에서 가비지 컬렉션을 수행하는 부분을 **가비지 컬렉터**라고 부릅니다.

### Garbage Collector의 원리
GC 작업을 하는 가비지 컬렉터는 다음과 같은 일을 합니다.
- 메모리 할당
- 사용중인 메모리 인식
- 사용하지 않는 메모리 인식

![img_1.png](img_1.png)

JVM에는 Heap 메모리 영역이 존재합니다.

Heap 메모리의 각 영역을 간략히 설명하자면,
- Young : 비교적 젊은 Reference가 살아있는 곳
  - Eden : Young 영역 중에서도 특히 갓 생성된 Reference가 살아있는 곳
- Old : 특정 횟수 이상 살아남은 Reference가 살아있는 곳
- Permanent : Method Area의 메타정보가 기록된 곳

으로 정리할 수 있습니다.

### Minor GC와 Major GC
Young 영역에서 발생한 GC를 Minor GC라고 하며, 여기서 실행되는 알고리즘을 **Stop and Copy 알고리즘**이라고 부릅니다.
Stop and Copy 알고리즘은 CG의 빈도를 높여 자잘한 청소작업을 여러번하여
사용자로 하여금 프로그램이 정지되는 경험을 주지 않게하고, 단편화 역시 처리하는 알고리즘입니다. 
> 대부분의 객체는 생성되고 얼마안돼 Unreachable하게 되는데, 대부분의 오래된 객체는 젊은 객체를 적게 참조하기 때문입니다.

나머지 두 영역에서 발생한 GC를 Major GC라고 하며, 메모리가 커서 성능이슈가 발생할 수 있습니다.

### 누가 쓰레기(Garbage)인가?
가비지 컬렉터는 그럼 정리할 쓰레기를 어떻게 판단 할까요?

바로 Reachable과 Unreachable, 즉 치우면 안되는 것과 치워야 하는 것으로 구분하여 판단합니다.
![img_2.png](img_2.png)
그림에 화살표로 이어진 Object들은 참조가 이루어진 것으로 Reachable 상태이고, 반대로 화살표로 이어지지 않은 Object들은 참조가 없는 것으로 Unreachable 상태입니다.
> 가비지 컬렉션은 특정 객체가 쓰레기인지 아닌지 판단하기 위해서 도달성, 도달능력이라는 개념을 적용합니다.
> 객체에 유효한 레퍼런스가 없다면 Unreachable 상태로 구분하고 수거의 대상이 되는 것입니다.

이렇게 상태로 구분이된 Object들은 GC의 알고리즘과 구현방식에 의해 이동, 압축 및 삭제를 거치게 됩니다.

[Garbage Collector 제대로 알기](https://velog.io/@recordsbeat/Garbage-Collector-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%95%8C%EA%B8%B0)
[가비지 컬렉션, 컬렉터(Garbage Collection)란?](https://blog.metafor.kr/163)

# 디스페처 서블릿은 어떤 역할을 하는지 설명해주세요

### 먼저 서블릿이란 무엇인가?
클라이언트의 요청에 그 결과를 다시 전송해주는데 이러한 역할을 하는 자바 프로그램

### 디스패처 서블릿의 정의
디스패처 서블릿은 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러

### 디스패처 서블릿의 장점 
과거에는 모든 서블릿을 URL 매핑을 위해 web.xml에 등록해주어야 했지만,
디스패처 서블릿이 해당 어플리케이션으로 들어오는 모든 요청을 핸들링해주고 공통 작업을 처리함

### 디스패처 서블릿의 동작 방식
![dispatcher servlet.png](dispatcher servlet.png)
디스패처 서블릿을 통해 요청을 처리할 컨트롤러를 찾아서 위임하고 그 결과를 받아옴
<br>
<br>  
  
# POJO(Plain-Old-Java-Object)란 무엇인가?  
  
POJO(Plain-Old-Java-Object)는 말 그대로 순수한 자바 오브젝트를 뜻한다.  
POJO라는 개념은 예전에 JavaEE등의 중량 프레임워크(특히 EJB) 을 사용하면서 단순한 자바 오브젝트를 사용해서 개발하는 것이 아닌 프레임워크에 종속적인 부분으로 개발을 진행했다.  
그로 인하여 모듈의 교체, 시스템 업그레이드 시 종속성으로 인한 불편함이 발생을 했고, 해당 프레임워크에 종속된 무거운 객체를 만들게 되는 것에 반발하여 2000년 9월 마틴 파울러, 레베카 파슨, 조쉬 맥킨지 등이 사용하기 시작한 용어이다.<br>
### POJO를 지킨 예제  
```java
public class Member {
    private String id;
    private String password;
  
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

