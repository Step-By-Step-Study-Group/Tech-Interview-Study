# 💬 목차

[객체지향 프로그래밍](#객체지향-프로그래밍)<br/>
[객체지향 vs 절차지향](#객체지향vs프로그래밍)  
[MSA와 기존 아키텍처와의 차이점](#MSA와-기존-아키텍처와의-차이점)

### 

## 객체지향 프로그래밍
**OOP( Object-Oriented Programming )**

프로그래밍 패러다임 중 하나로, 실제 세계의 객체를 프로그래밍에서도 객체로 바라보고 이를 기반으로 프로그램을 작성하는 방법론

### 캡슐화( Encapsulation )

 객체의 속성과 행위를 하나로 묶어서 외부에서의 접근을 제한하는 것을 의미합니다. 이를 통해 객체 내부의 동작 방식을 숨기고 외부에서는 객체가 제공하는 인터페이스를 통해 객체와 상호작용할 수 있습니다.

- ### 정보은닉

  - 캡슐화를 통해 **객체의 상태 정보를 숨길 수 있습니다.**

  - 객체 내부의 데이터나 구현 세부사항을 감춤으로써 **코드의 복잡성을 낮출 수 있습니다.** 이를 통해 코드의 **안정성을 높일 수 있습니다.**

- ### 모듈화

  - 캡슐화를 통해 객체 내부의 세부적인 구현을 숨기면서 **객체와 상호작용할 수 있는 인터페이스를 제공**합니다.

  - 이를 통해 코드의 모듈화가 가능하고, **각 모듈은 독립적으로 개발 및 테스트가 가능**합니다.

- ### 유연성

  - 객 체의 내부 구현을 숨김으로써 **객체의 외부 인터페이스가 변경되지 않는 한 객체의 내부 구현이 변경될 수 있습니다**

- ### 보안성

  - 캡슐화를 통해 데이터와 구현 세부사항을 숨기므로, **불법적인 접근으로부터 데이터를 보호**할 수 있습니다.

- ### 성능 저하

  - 객체 내부의 데이터를 외부에서 접근할 수 없도록 제한하면, **객체 내부에서의 데이터 접근이 느려질 수 있습니다.**

- ### 제한된 접근

  - 캡슐화를 통해 제한된 인터페이스만을 제공하므로, **객체의 모든 내부 정보에 대한 접근이 불가능**합니다.

- ### 디버깅이 어려울 수 있음

  - 객체 내부의 구현이 외부에 숨겨져 있으므로, 디버깅이 어려울 수 있습니다. **객체 내부에서 발생한 문제를 찾는 것이 어려울 수 있습니다.**

### 상속( Inheritance )

 이미 정의된 클래스를 기반으로 새로운 클래스를 정의하는 것을 의미합니다. 상속을 통해 기존 클래스의 속성과 행위를 그대로 이용하면서 새로운 기능을 추가하거나 수정할 수 있습니다.

- ### 코드 재사용성

  - 부모 클래스의 기능을 자식 클래스에서 재사용가능

  - 새로운 클래스를 작성할 때 기존의 클래스를 그대로 활용할 수 있으므로 **코드의 중복을 줄이고 개발 시간을 단축**할 수 있습니다.

- ### 유지보수성

  - 코드의 유지보수가 쉬워집니다.

  - 클래스의 수정이 필요할 때 부모 클래스 기능만 변경하면 자식 클래스에서 변경하지 않고 그대로 사용 할 수 있슴

- ### 다형성

  - 상속을 통해 자식 클래스에서 부모 클래스의 메서드를 오버라이딩하여 다양한 구현을 제공할 수 있습니다. 이를 통해 코드의 유연성과 확장성을 높일 수 있습니다.

- ### 추상화

  - 코드의 가독성을 높일 수 있습니다.

  - 상속을 통해 객체를 일반화시키고 추상화할 수 있습니다.

- ### 복잡성

  - **상속을 남용하면 클래스 간의 관계가 복잡해질 수 있습니다**. 클래스의 계층구조가 깊어지고, 메서드 오버라이딩과 다형성을 활용한 구현이 많아질수록 클래스의 관계와 동작을 이해하기 어려워집니다.

- ### 의존성

  - **부모 클래스와 자식 클래스 간에 강한 결합 관계가 생길 수 있습니다**.

  - 이는 하나의 클래스를 수정할 때 다른 클래스도 함께 수정해야 할 수 있음을 의미합니다.

- ### 보안성

  - **부모 클래스의 내부 정보가 자식 클래스에 노출될 수 있습니다**

  - 자식 클래스가 부모 클래스의 기능을 상속받기 때문에,이를 해결하기 위해 **캡슐화** 등의 기법을 사용해야 합니다.

### 다형성( Polymorphism )

  하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다. 다형성을 통해 같은 코드가 다양한 객체에 대해 다른 동작을 수행할 수 있습니다.

- ### 코드 재사용성

  - **유지보수 비용을 줄이고 개발 속도를 높일 수 있음**

  - 같은 인터페이스를 구현하는 다른 클래스들을 사용할 수 있으므로, 코드를 재사용할 수 있습니다.

- ### 코드 가독성

  - **코드를 단순화하고 가독성을 높일 수 있습니다.**

  - 객체의 동작을 구현하는 코드와 실제로 호출하는 코드를 분리할 수 있습니다.

- ### 유연성

  - 다형성을 사용하면 같은 인터페이스를 구현하는 **다른 클래스들을 동적으로 선택할 수 있습니다.** 

- ### 확장성

  - 새로운 클래스를 추가하거나 기존 클래스를 변경할 때, 기존 코드에 영향을 미치지 않으면서 변경할 수 있습니다.

- ### 오버헤드

  - **객체를 생성하고 호출하는 과정에서 오버헤드가 발생할 수 있습니다.**

  - 프로그램의 실행 속도를 늦추는 원인이 될 수 있습니다.

- ### 복잡성

  - 클래스와 인터페이스의 계층구조가 복잡해질 수 있음

- ### 오류 발생 가능성

  - **런타임 시 객체의 실제 타입이 무엇인지 확인해야 합니다.**

  - 프로그램에서 오류가 발생할 가능성을 높일 수 있습니다.

### OOP의 한계
- **객체지향 프로그래밍의 구현이 어렵다.** 객체지향 프로그래밍은 절차지향 프로그래밍보다 개념이 복잡하고 구현하기가 어려울 수 있다.
- **메모리 사용량이 많아진다.** 객체지향 프로그래밍은 객체를 만들어서 사용하기 때문에, 메모리 사용량이 증가할 수 있다.
- **실행 속도가 상대적으로 느릴 수 있다**. 객체지향 프로그래밍은 함수 호출이나 객체 생성 등의 오버헤드가 존재하기 때문에, 절차지향 프로그래밍에 비해 실행 속도가 느릴 수 있다.

### OOP의 원칙

**SOLID 원칙**

SRP(Single Responsibility Principle) 단일 책임 원칙

- 하나의 클래스는 하나의 책임만 가져야 한다.

OCP(Open-Closed Principle) 개방-폐쇄 원칙

- 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.

LSP(Liskov Substitution Principle) 리스코프 치환 원칙

- 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다.

ISP(Interface Segregation Principle) 인터페이스 분리 원칙

- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.

DIP(Dependency Inversion Principle) 의존 역전 원칙

- 추상화된 것은 구체적인 것에 의존하면 안 된다.

## 객체지향vs프로그래밍

### 객체지향( Object-Oriented Programming )

컴퓨터 프로그래밍 패러다임 중 하나로, 프로그램을 객체의 집합으로 나타내고, 이러한 객체들 간의 상호작용을 통해 프로그램을 구성하는 방식

### 절차지향( Procedural Programming )

프로그램을 일련의 순차적인 단계나 절차로 구성하는 방식

## 차이

### 추상화( Abstract )

- 객체지향에서는 **객체의 추상화**가 중요
- 절차지향에서는 **함수의 추상화**가 중요

### 캡슐화( Encapsulation )

- 객체지향에서는 객체의 데이터와 해당 데이터를 처리하는 메서드를 캡슐화하여 외부에서의 직접적인 접근을 제한하고, 메서드를 통해 간접적인 접근을 유도
- 절차지향에서는 데이터와 함수를 구분하여 처리

### 상속성( Inheritance )

- 객체지향에서는 클래스 간의 상속관계를 통해 코드 재사용성과 유지보수성을 향상
- 절차지향에서는 이와 같은 개념이 없습니다

### 다형성( Polymorphism )

- 객체지향에서는 메서드 오버라이딩 등을 통해 하나의 인터페이스로 여러 개의 구현을 제공하는 다형성 개념을 제공
- 절차지향에서는 이와 같은 개념이 없습니다.

### 처리속도

일반적으로 절차지향 프로그래밍의 처리속도가 객체지향으로 프로그래밍 했을 때 보다 빠르다

## 선택 근거

객체지향은 대규모 복잡한 프로그램을 작성할 때 유용하며, 코드의 재사용성과 확장성을 높일 수 있습니다. 하지만 작은 규모의 프로그램에서는 절차지향이 더 간단하고 직관적일 수 있습니다

# MSA와 기존 아키텍처와의 차이점

### **모놀리식 아키텍처**

**하나의 서비스 또는 애플리케이션이 하나의 거대한 아키텍처를 가지는 것**

장점

1. 테스트가 용이하다
2. 빠르게 간단한 서비스를 만들 수 있다.

단점

1. 수정사항이 생기면 전체를 다시 빌드하고 배포해야 함
2. 프로젝트 규모가 커지면 구동 시간이 늘어남
3. 일부분의 오류가 전체에 영향을 미칠 수 있음

### **MSA(Microservice Architecture)**

**하나의 큰 어플리케이션을 여러개의 작은 어플리케이션으로 만들어 변경과 조합이 가능**

장점

1. 유지보수가 용이함
2. 거대한 서비스도 빠르게 수정 가능
3. 각 기능에 따라 다른 언어 선택이 가능

단점

1. 모니터링이나 서비스가 힘듬
2. 서비스간 호출시 통신비용이 증가함
3. 상대적으로 테스트 하기 힘듬